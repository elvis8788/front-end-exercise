<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Front End Exercise</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style type="text/css">
        /*problem3 gap*/
        html {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, hsla(197, 100%, 63%, 1) 0%, hsla(294, 100%, 55%, 1) 100%);
            min-height: 100vh;
        }

        body {
            margin: 0;
            padding: 10px;
            min-height: 100vh;
        }

        #app {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        #app > div {
            --span: 1;
            aspect-ratio: var(--span) / 1;
            /*2 gaps*/
            flex-basis: calc((100% - 20px) * (var(--span) / 3));
            background: hsla(197, 100%, 63%, 1);
            border: 10px solid white;
            border-radius: 15px;
            text-align: center;
            box-sizing: border-box;
            padding: 10px;
            font-weight: bold;
            font-size: 1.2em;
            color: #333;
            flex-grow: 0;
            flex-shrink: 0;
        }
        /* remove  last div margin */
        #app > div:nth-child(3n) {
            margin-right: 0;
        }
        /*load style*/
        #load {
            width: 100%;
            padding: 15px;
            margin: 20px 0;
            background: hsla(294, 100%, 55%, 0.8);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background 0.3s;
            flex-basis: 100%;
        }
        #load:hover {
            background: hsla(294, 100%, 55%, 1);
        }
        /* responsive  - screen's width over than 1200px*/
        @media (min-width: 1200px) {
            #app > div {
                /* display 4 columns */
                flex-basis: calc((100% - 30px) * (var(--span) / 4));
            }
            #app {
                gap: 10px;
            }
        }
        /* responsive  - screen's width less than  800px*/
        @media (max-width: 800px) {
            #app > div {
                /* display 2 columns */
                flex-basis: calc((100% - 10px) * (var(--span) / 2));
            }
            #app {
                gap: 10px;
            }
        }
        /* responsive  - screen's width less than  500px*/
        @media (max-width: 500px) {
            #app > div {
                /* display 1 columns */
                flex-basis: 100%;
            }
            #app {
                gap: 10px;
            }
        }
    </style>
    <script type="text/javascript">
        /////////////////
        // DO NOT EDIT //
        /////////////////

        const fetchData = (() => {
            const fakeData = [];
            const dataCount = Math.floor(Math.random() * 200) + 50;

            for (let i = 0; i < dataCount; i++) {
                fakeData.push({
                    id: i + 1,
                    span: Math.random() > 0.5 ? Math.floor(Math.random() * 3) + 1 : 1,
                });
            }

            return (startIndex, endIndex) => {
                const p = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve({
                            length: fakeData.length,
                            data: fakeData.slice(startIndex, endIndex),
                        });
                    }, 333);
                });
                return p;
            };
        })();

        ////////////////////////
        // END of DO NOT EDIT //
        ////////////////////////
    </script>
</head>
<body>
<section id="app">
    <div v-for="d in sortedData" :style="{ '--span': d.span }" :key="d.id">{{ d.id }}</div>
    <button id="load" @click="getNextPage">Load more…</button>
</section>
<script type="text/javascript">
    const {createApp, ref, computed, onMounted, onUnmounted} = Vue;

    createApp({
        setup() {
            const columns = 3;
            const pageSize = 10;
            const lastFetchedIndex = ref(0);
            const data = ref({length: 0, data: []});
            const sortedData = computed(() => {
                const s = [...data.value.data];
                // Problem 1: your code here…
                if (s.length === 0) return [];
                // mock columns = 3 method
                const result = [];
                const columns = [[], [], []]; //init 3 columns
                const columnHeights = [0, 0, 0]; // current Height each column
                for (const columnItem of s) {
                    let targetColumn = 0;
                    let minHeight = columnHeights[0];
                    for (let i = 1; i < 3; i++) {
                        if (columnHeights[i] < minHeight) {
                            minHeight = columnHeights[i];
                            targetColumn = i;
                        }
                    }
                    columns[targetColumn].push(columnItem);
                    // update height
                    if (columnItem.span === 1) {
                        columnHeights[targetColumn] += 1;
                    } else if (columnItem.span === 2) {
                        // span == 2 need 2columns
                        const startCol = targetColumn <= 1 ? targetColumn : 1; // dont over border
                        columnHeights[startCol] += 1;
                        columnHeights[startCol + 1] += 1;
                    } else if (columnItem.span === 3) {
                        // span == 3 need 3columns
                        columnHeights[0] += 1;
                        columnHeights[1] += 1;
                        columnHeights[2] += 1;
                    }
                }
                //set maxlength
                const maxLength = Math.max(columns[0].length, columns[1].length, columns[2].length);

                for (let i = 0; i < maxLength; i++) {
                    // add data to first column
                    if (i < columns[0].length) {
                        result.push(columns[0][i]);
                    }
                    // add data to second column
                    if (i < columns[1].length) {
                        result.push(columns[1][i]);
                    }
                    // add data to third column
                    if (i < columns[2].length) {
                        result.push(columns[2][i]);
                    }
                }
                return result;
            });

            async function getNextPage() {
                const d = await fetchData(
                    lastFetchedIndex.value,
                    lastFetchedIndex.value + pageSize
                );
                lastFetchedIndex.value = lastFetchedIndex.value + d.data.length;
                data.value = {length: d.length, data: [...data.value.data, ...d.data]};
            }

            // Problem 2 infinite scrolling
            const observer = ref(null);

            const initInfiniteScroll = () => {
                const loadButton = document.getElementById('load');
                if (loadButton) {
                    // create Intersection Observer
                    observer.value = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            // load when there are more data
                            if (lastFetchedIndex.value < data.value.length) {
                                getNextPage();
                            }
                        }
                    }, {
                        root: null,
                        rootMargin: '0px 0px 100px 0px', // trigger bottom 100px
                        threshold: 0.1 // trigger 10% part
                    });

                    // 开始观察按钮
                    observer.value.observe(loadButton);
                }
            }

            onMounted(() => {
                getNextPage();
                // delay for Dom loaded
                setTimeout(initInfiniteScroll, 100);
            });
            onUnmounted(() => {
                // destroy observer
                if (observer.value) {
                    observer.value.disconnect();
                }
            });

            return {
                data,
                sortedData,
                lastFetchedIndex,
                getNextPage,
            };
        },
    }).mount('#app');
</script>
</body>
</html>
